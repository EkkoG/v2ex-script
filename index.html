<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <link rel="icon" href="/favicon.ico"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.2.40/vue.global.js"></script>
  <title>Vite App</title>
</head>
<body>
<div id="app"></div>
<script>
  // ==UserScript==
  // @name         New Userscript
  // @namespace    http://tampermonkey.net/
  // @version      0.1
  // @description  try to take over the world!
  // @author       You
  // @match        https://*.v2ex.com/
  // @match        https://*.v2ex.com/?tab=*
  // @match        https://*.v2ex.com/t/*
  // @match        https://*.v2ex.com/recent*
  // @match        https://*.v2ex.com/go/*
  // @icon         https://www.google.com/s2/favicons?sz=64&domain=v2ex.com
  // @grant        none
  // ==/UserScript==


  const isDev = true

  if (window.top[0]) {
    window.win = () => window.top
    window.win().url = 'https://www.v2ex.com'
    // window.win().url = location.origin
    window.win().isFrame = true
    //直接使用v2的jquery，因为v2对jquery作了修改，加了一些header，缺少这些header发送请求会报403
    window.$ = window.win().$
  } else {
    window.win = () => window
    window.win().url = 'https://www.v2ex.com'
    // window.win().url = location.origin
    window.win().isFrame = false
  }

  window.win().initPost = {
    replies: [],
    nestedReplies: [],
    username: '',
    title: '',
    id: '',
    type: 'post',
    once: '',
    replyCount: 0,
    clickCount: 0,
    thankCount: 0,
    collectCount: 0,
    isFavorite: false,
    isIgnore: false,
    isThanked: false,
    isReport: false,
    RightbarHTML: '',
  }
  window.win().doc = window.win().document
  window.win().query = (v) => window.win().document.querySelector(v)
  window.win().queryAll = window.win().document.querySelectorAll
  window.win().clone = (val) => JSON.parse(JSON.stringify(val))
  window.win().user = {}
  window.win().pageType = ''
  window.win().pageData = {pageNo: 1}
  window.win().adIndex = 0 //广告下标，用于区分广告id
  window.win().adList = []//广告列表，用于延时通知vue复制广告的innerHTML，因为一开始就复制，google的js不能正常加载
  //待删除元素列表。等vue加载好了，再删除。之所以要用数组，是因为帖子中间夹杂着广告。
  // 只删除帖子，广告会被移除到其他地方，保证google的js能正常加载出广告来
  window.win().waitDelElList = []

  window.parse = {
    //解析帖子内容
    async parsePostContent(post = {}, body, htmlText) {
      //如果没有正文（点的本站的a标签），才会解析正文
      if (!post.title || !post.content_rendered) {
        let main = body.find('#Main')
        let topic_content = main.find('.topic_content')
        if (topic_content.length) {
          post.content_rendered = topic_content.html()
        }
        let title = main.find('.header h1')
        if (title.length) {
          post.title = title.html()
        }
        let as = main.find('.header a')
        if (as[2]) {
          post.nodeUrl = as[2].href
          post.node = as[2].innerText
        }
        let aName = main.find('.header small a:nth-child(1)')
        if (aName) {
          post.username = aName[0].innerText
          post.date = aName[0].nextElementSibling.innerText
        }
        let avatarNode = main.find('.header .fr img')
        if (avatarNode.length) {
          post.avatar = avatarNode[0].src
        }
      }

      let subtles = body.find('.subtle')
      if (subtles.length) {
        post.subtlesHtml = `
        <div class="subtlesHtml">${Array.from(subtles).reduce((p, i) => {
          p += `<div class="subtle">${i.innerHTML}</div>`
          return p
        }, '')}</div>
        `
      }

      let once = htmlText.match(/var once = "([\d]+)";/)
      // console.log(once)
      if (once && once[1]) {
        post.once = once[1]
      }

      post.isReport = htmlText.includes('你已对本主题进行了报告')

      let topic_buttons = body.find('.topic_buttons')
      if (topic_buttons.length) {
        let favoriteNode = topic_buttons.find('.tb:first')
        if (favoriteNode.length) {
          post.isFavorite = favoriteNode[0].innerText === '取消收藏'
        }
        let ignoreNode = topic_buttons.find('.tb:nth-child(3)')
        if (ignoreNode.length) {
          post.isIgnore = ignoreNode[0].innerText === '取消忽略'
        }
        //
        let thankNode = topic_buttons.find('#topic_thank .tb')
        if (!thankNode.length) {
          post.isThanked = true
        }

        let topic_stats = topic_buttons.find('.topic_stats')
        //topic_stats = $(`<div class="fr topic_stats" style="padding-top: 4px;">9569 次点击 &nbsp;∙&nbsp; 28 人收藏 &nbsp; ∙&nbsp; 1 人感谢 &nbsp; </div>`)
        //收藏数、感谢数
        if (topic_stats.length) {
          let text = topic_stats[0].innerText
          let reg1 = text.matchAll(/([\d]+)[\s]*人收藏/g)
          let collectCountReg = [...reg1]
          if (collectCountReg.length) {
            post.collectCount = Number(collectCountReg[0][1])
          }
          // console.log([...collectCountReg])
          let reg2 = text.matchAll(/([\d]+)[\s]*人感谢/g)
          let thankCountReg = [...reg2]
          if (thankCountReg.length) {
            post.thankCount = Number(thankCountReg[0][1])
          }
          // console.log([...thankCountReg])
        }
      }

      //点击数
      let baseInfo = body.find('.header small.gray')
      if (baseInfo.length) {
        let text = baseInfo.text()
        let reg = text.matchAll(/([\d]+)[\s]*次点击/g)
        let clickCountReg = [...reg]
        if (clickCountReg.length) {
          post.clickCount = Number(clickCountReg[0][1])
        }
      }

      // let Rightbar = window.win().query('#Rightbar')
      let Rightbar = body.find('#Rightbar')
      if (Rightbar.length) {
        post.RightbarHTML = Rightbar[0].innerHTML
        //让修改背景的样式失效
        post.RightbarHTML = post.RightbarHTML.replace('type="text/css"', 'type="text/css1"')
      }
      // console.log('基本信息', post)
      return post
    },
    //获取帖子所有回复
    async getPostAllReplies(post = {}, body, htmlText, pageNo = 1) {
      if (body.find('#no-comments-yet').length) {
        return post
      }

      let box = body.find('#Main > .box')[1]
      let cells = box.querySelectorAll('.cell')
      cells = Array.from(cells)

      //获取创建时间
      let snow = cells[0].querySelector('.snow')
      post.createDate = snow?.nextSibling.nodeValue.trim() || ''

      let repliesMap = []
      if (cells[1].id) {
        repliesMap.push({i: pageNo, replyList: this.parsePageReplies(cells.slice(1))})
        let replies = this.getAllReply(repliesMap)
        post.replies = replies
        post.replyCount = replies.length
        post.allReplyUsers = Array.from(new Set(replies.map(v => v.username)))
        let nestedList = this.createNestedList(replies, post.allReplyUsers)
        if (nestedList) post.nestedReplies = nestedList
        return post
      } else {
        let promiseList = []
        // console.log(this.current.repliesMap)
        return new Promise((resolve, reject) => {
          repliesMap.push({i: pageNo, replyList: this.parsePageReplies(cells.slice(2, cells.length - 1))})

          let pages = cells[1].querySelectorAll('a')
          pages = Array.from(pages)
          // console.log(pages)
          let url = window.win().url + '/t/' + post.id
          for (let i = 0; i < pages.length; i++) {
            let currentPageNo = Number(pages[i].innerText)
            if (currentPageNo == pageNo) continue
            promiseList.push(this.fetchPostOtherPageReplies(url + '?p=' + currentPageNo, currentPageNo))
          }
          Promise.allSettled(promiseList).then(
              (results) => {
                results.filter((result) => result.status === "fulfilled").map(v => repliesMap.push(v.value))
                let replies = this.getAllReply(repliesMap)
                post.replies = replies
                post.replyCount = replies.length
                post.allReplyUsers = Array.from(new Set(replies.map(v => v.username)))
                let nestedList = this.createNestedList(replies, post.allReplyUsers)
                if (nestedList) post.nestedReplies = nestedList
                resolve(post)
              }
          );
        })
      }
    },
    //请求帖子其他页的回复
    fetchPostOtherPageReplies(url, pageNo) {
      return new Promise(resolve => {
        $.get(url).then(res => {
          let s = res.match(/<body[^>]*>([\s\S]+?)<\/body>/g)
          let box = $(s[0]).find('#Main .box')[1]
          let cells = box.querySelectorAll('.cell')
          cells = Array.from(cells)
          resolve({i: pageNo, replyList: this.parsePageReplies(cells.slice(2, cells.length - 1))})
        })
      })
    },
    //解析页面的回复
    parsePageReplies(nodes) {
      let replyList = []
      nodes.forEach((node, index) => {
        if (!node.id) return
        let item = {
          thankCount: 0,
          isThanked: false,
          isOp: false,
          id: node.id.replace('r_', '')
        }
        let reply_content = node.querySelector('.reply_content')
        // console.log('reply_content',reply_content)
        item.reply_content = reply_content.innerHTML
        item.reply_text = reply_content.innerText

        let {users, floor} = this.parseReplyContent(item.reply_content)
        item.replyUsers = users
        item.replyFloor = floor
        if (index === 5) {
          // console.log(item)
          // console.log(reply_content.innerText)
          // console.log(reply_content.innerHTML)
        }
        let ago = node.querySelector('.ago')
        item.date = ago.innerText

        let userNode = node.querySelector('strong a')
        item.username = userNode.innerText
        let avatar = node.querySelector('td img')
        item.avatar = avatar.src
        let no = node.querySelector('.no')
        item.floor = Number(no.innerText)

        let thank_area = node.querySelector('.thank_area')
        if (thank_area) {
          item.isThanked = thank_area.classList.contains('thanked')
        }
        let small = node.querySelector('.small')
        if (small) {
          item.thankCount = Number(small.innerText)
        }
        let op = node.querySelector('.op')
        if (op) {
          item.isOp = true
        }
        // console.log('item', item)

        replyList.push(item)
      })
      return replyList
    },
    //解析回复内容，解析出@用户，回复楼层。用于后续生成嵌套楼层
    parseReplyContent(str) {
      if (!str) return
      let users = []
      let getUsername = (userStr) => {
        let endIndex = userStr.indexOf('">')
        if (endIndex > -1) {
          let user = userStr.substring(0, endIndex)
          if (!users.find(i => i === user)) {
            users.push(user)
          }
        }
      }
      // str = `@<a hr a> #4 @<a1 href="/member/Eiden1">Eiden1</a1>   @<a href="/member/Eiden111">Eiden21</a> #11   这也是执行阶段，所谓的安装也是程序业务的 setup 。<br>windows 、Android 并没有系统级的 CD-KEY 。`
      let floorReg = /@<a href="\/member\/[\s\S]+?<\/a>[\s]+#([\d]+)/g
      let userReg = /@<a href="\/member\/([\s\S]+?)<\/a>/g
      let hasFloor = str.matchAll(floorReg)
      let res = [...hasFloor]
      // console.log('总匹配', res)
      let floor = -1
      if (res.length) {
        floor = Number(res[0][1])
      }
      let has = str.matchAll(userReg)
      let res2 = [...has]
      // console.log('总匹配', res2)
      if (res2.length > 1) {
        res2.map(item => {
          getUsername(item[1])
        })
      }
      if (res2.length === 1) {
        getUsername(res2[0][1])
      }
      // console.log('用户', users)
      // console.log('楼层', floor)
      return {users, floor}
    },
    //获取帖子详情
    async getPostDetail(post = {}, body, htmlText, pageNo = 1) {
      post = await this.parsePostContent(post, body, htmlText)
      return await this.getPostAllReplies(post, body, htmlText, pageNo)
    },
    getAllReply(repliesMap = []) {
      return repliesMap.sort((a, b) => a.i - b.i).reduce((pre, i) => {
        pre = pre.concat(i.replyList)
        return pre
      }, [])
    },
    //生成嵌套回复
    createNestedList(allList = []) {
      if (!allList.length) return []
      if ((Date.now() - window.win().lastCallDate) < 1000) {
        // console.log('短时间内，重复调用,因为监听了replies,所以打开时会触发两次。第二次不管他')
        return false
      }
      // console.log('cal-createNestedList', Date.now())

      let list = JSON.parse(JSON.stringify(allList))
      let nestedList = []
      list.map((item, index) => {
        let startList = list.slice(0, index)
        let startReplyUsers = Array.from(new Set(startList.map(v => v.username)))

        let endList = list.slice(index + 1)

        if (index === 0) {
          item.level = 0
          nestedList.push(this.findChildren(item, endList, list))
        } else {
          let isParentReply = false
          // if (item.replyFloor === -1) {
          //   isParentReply = true
          // }
          if (item.replyUsers.length) {
            if (item.replyUsers.length > 1) {
              isParentReply = true
            } else {
              isParentReply = !startReplyUsers.find(v => v === item.replyUsers[0]);
            }
          } else {
            isParentReply = true
          }
          if (isParentReply) {
            item.level === 0
            nestedList.push(this.findChildren(item, endList, list))
          }
        }
      })
      // console.log('replies长度', allList)
      // console.log('nestedList长度', nestedList)
      window.win().lastCallDate = Date.now()
      return nestedList
    },
    //查找子回复
    findChildren(item, endList, all) {
      const fn = (child, endList2, parent) => {
        child.level = parent.level + 1
        let rIndex = all.findIndex(v => v.floor === child.floor)
        if (rIndex > -1) {
          all[rIndex].isUse = true
        }
        parent.children.push(this.findChildren(child, endList2, all))
      }
      // console.log('endList', endList)
      item.children = []
      // if (item.floor ==8)debugger
      for (let i = 0; i < endList.length; i++) {
        let currentItem = endList[i]

        //如果已被使用，直接跳过
        if (currentItem.isUse) continue

        let endList2 = endList.slice(i + 1)
        //注： 2022-10-26，回复被忽略了之后，会占据原来的楼层
        //但是，未忽略这条回复的人，看到的楼层和忽略回复的人看到的不一样，导致以楼层号来判断会出问题
        // if (currentItem.replyFloor !== -1) {
        if (false) {
          if (currentItem.replyFloor === item.floor) {
            fn(currentItem, endList2, item)
          }
        } else {
          if (currentItem.replyUsers.length === 1) {
            // //找出自己最近一条正常回复，以那条为搜索终点
            // let rIndex = endList.findIndex(v => v.username === item.username && (currentItem.replyUsers.length === 0 && currentItem.replyFloor === -1))
            // if (rIndex > -1) {
            //   endList2 = endList.slice(i + 1, rIndex)
            // }
            //如果是下一条是同一人的回复，那么跳出循环。children从下一条开始找
            if (currentItem.username === item.username) {
              //自己回复自己的特殊情况
              if (currentItem.replyUsers[0] === item.username) {
                fn(currentItem, endList2, item)
                continue
              }
              //有种特殊情况，就是自己连着评论了两条。然后后面的人以#号的方式 回复了自己第一条。
              //如果检测到下条是自己的回复，直接略过的话就会丢失第一条的所有楼中楼回复
              //具体如下
              // 自己：1楼，在for的时候，如果碰到 2楼不能直接跳过，直接略过的话就会丢失第一条的所有楼中楼回复，即3楼。所以应该以3楼为起点
              //进行楼中楼查找，查找完了再跳过
              // 自己：2楼
              // 别人：指定回复1楼
              // endList2.map((v, vi) => {
              //   if (v.replyFloor === item.floor) {
              //     fn(v, endList.slice(vi + 1), item)
              //   }
              // })
              break
            } else {
              if (currentItem.replyUsers[0] === item.username) {
                fn(currentItem, endList2, item)
              }
            }
          }
        }
      }
      return item
    },
    //解析其他页面
    parseOtherPage(html, pageType) {
      let bodyText = html.match(/<body[^>]*>([\s\S]+?)<\/body>/g)
      let body = $(bodyText[0])

      if (pageType === 'recent') {
        // box = window.win().query('#Wrapper #Main .box')
        // let arr = Array.from(box.children)
        // let start = arr.findIndex(v => v.classList.contains('item'))
        // list = arr.slice(start, arr.length - 1)
        let list = body.find('.item')
        let res = this.parsePagePostList(Array.from(list))
        let page = body.find('.cell:last').html()
        return {...res, page}
      }
      if (pageType === 'nodePage') {
        let topics = body.find('#TopicsNode')
        let list = topics.children()
        let res = this.parsePagePostList(Array.from(list))
        let page = topics.next().html()
        return {...res, page}
      }
    },
    //解析页面帖子列表
    parsePagePostList(list) {
      let postList = []
      let apiList = []
      list.forEach(function (listItem) {
        if (!listItem.classList.contains('cell')) {
          window.win().$adListEl.append(listItem)

          window.win().adIndex += 1
          let adId = 'ad' + window.win().adIndex
          listItem.id = adId
          let item = {
            type: 'ad',
            id: adId,
            innerHTML: listItem.innerHTML
          }
          postList.push(item)
          window.win().adList.push(item)
          // listItem.remove()
          return
        }
        let item = window.win().clone(window.win().initPost)
        let bg = listItem.style['background-image']
        item.bg = bg
        let item_title = listItem.querySelector('.item_title a')
        let href = item_title.href
        item.id = href.substring(href.indexOf('/t/') + 3, href.indexOf('#'))
        item.title = item_title.innerText

        let topic_info = listItem.querySelector('.topic_info')
        let userNode = topic_info.querySelector('strong a')
        item.username = userNode.innerText
        let timeNode = listItem.querySelector('.topic_info span')
        item.date = timeNode.innerText
        let tagNode = topic_info.querySelector('.node')
        if (tagNode) {
          item.node = tagNode.innerText
        }
        let countNode = listItem.querySelector('.count_livid')
        item.replyCount = countNode ? countNode.innerText : 0

        let avatar = listItem.querySelector('img')
        item.avatar = avatar.src

        let url = window.win().location.origin + '/api/topics/show.json?id=' + item.id
        // console.log(url)
        apiList.push(url)
        postList.push(item)
        window.win().waitDelElList.push(listItem)
        // listItem.remove()
      })
      setTimeout(() => {
        cbChecker({type: 'ad'})
      }, 3000)
      return {postList, apiList}
    },
    fetchAll(list) {
      return new Promise(resolve => {
        Promise.allSettled(list.map(url => $.get(url))).then(async (res) => {
          let ok = res.filter((r) => r.status === "fulfilled").map(v => v.value[0])
          let fail = res.filter((r) => r.status === "rejected")
          console.log('fail', fail)
          resolve(ok)
        });
      })
    }
  }

  async function sleep(time) {
    return new Promise(resolve => {
      // console.log('等待vue加载完成,第' + count + '次', Date.now())
      setTimeout(resolve, time)
    })
  }

  async function cbChecker(val, count = 0) {
    if (window.win().cb) {
      window.win().cb(val)
    } else {
      while ((!window.win().cb) && count < 20) {
        await sleep(500)
        count++
      }
      window.win().cb && window.win().cb(val)
    }
  }

  let location2 = window.win().location
  if (location2.pathname === '/') {
    window.win().pageType = 'home'
  } else if (location2.href.match(/.com\/?tab=/)) {
    window.win().pageType = 'home'
  } else if (location2.href.match(/.com\/go\//)) {
    window.win().pageType = 'nodePage'
  } else if (location2.href.match(/.com\/recent/)) {
    window.win().pageType = 'recent'
  } else {
    let r = location2.href.match(/.com\/t\/([\d]+)/)
    if (r) {
      window.win().pageType = 'post'
      window.win().pageData.id = r[1]
      if (location2.search) {
        let pr = location2.href.match(/\?p=([\d]+)/)
        if (pr) window.win().pageData.pageNo = Number(pr[1])
      }
    }
  }

  // console.log('type===', window.win().pageType, 'pageData===', window.win().pageData)
  // console.log('postList', window.win().postList)
  // console.log('init', window.win().init)

  //let $vue = document.createElement('iframe');$vue.src = 'http://localhost:3000/';document.body.appendChild($vue);

  window.win().canParseV2exPage = true
  //开发环境并且没有嵌套到v2ex的网页里面时，不要解析
  if (isDev && !window.win().isFrame) {
    window.win().canParseV2exPage = false
  }
  if (window.win().canParseV2exPage) {
    let top2 = window.win().query('.tools .top:nth-child(2)').text
    if (top2 !== '注册') {
      window.win().user = {
        username: top2,
        avatar: $('#Rightbar .box .avatar', window.win().doc).attr('src')
      }
    }

    window.win().cb = null
    window.win().vueCb = null
    window.win().postList = []

    let $section = document.createElement('section')
    $section.id = 'app'

    window.win().$adListEl = document.createElement('section')
    window.win().$adListEl.id = 'ad_list'
    window.win().$adListEl.style.position = 'fixed'
    window.win().$adListEl.style.left = '-100vw'
    window.win().$adListEl.style.top = '0'
    window.win().doc.body.append(window.win().$adListEl)

    let wrapper
    let box
    let list
    let res
    switch (window.win().pageType) {
      case 'nodePage':
        box = $('#Wrapper #Main .box:first')
        box.css({'box-shadow': 'unset'})

        let topics = $('#TopicsNode')
        topics.attr('id', 'app')
        list = topics.children()
        res = window.parse.parsePagePostList(Array.from(list))
        window.win().postList = res.postList
        window.parse.fetchAll(res.apiList).then(async r => {
          await cbChecker({type: 'list', value: r})
        })
        break
      case 'recent':
      case 'home':
        box = window.win().query('#Wrapper #Main .box')
        box.style.boxShadow = 'unset'
        wrapper = box.querySelector('.item')
        wrapper.before($section)
        let arr = Array.from(box.children)
        let start = arr.findIndex(v => v.classList.contains('item'))
        list = arr.slice(start, arr.length - 1)
        res = window.parse.parsePagePostList(list)
        window.win().postList = res.postList
        window.parse.fetchAll(res.apiList).then(async r => {
          await cbChecker({type: 'list', value: r})
        })
        break
      case 'post':
        box = window.win().query('#Wrapper #Main .box')
        box.after($section)
        window.parse.parsePostContent(
            {id: window.win().pageData.id},
            $(window.win().doc.body),
            window.win().doc.documentElement.outerHTML
        ).then(async res => {
          // console.log('详情页-基本信息解析完成', new Date())
          window.win().pageData.post = res
          await cbChecker({type: 'postContent', value: res}, 0)
        })

        window.parse.getPostAllReplies(
            {id: window.win().pageData.id},
            $(window.win().doc.body),
            window.win().doc.documentElement.outerHTML,
            window.win().pageData.pageNo
        ).then(async res => {
          // console.log('详情页-回复解析完成', new Date())
          window.win().pageData.post = Object.assign(window.win().pageData.post, res)
          await cbChecker({type: 'postReplies', value: res}, 0)
        })
        break
      default:
        console.error('未知页面')
        break
    }
  }

  //开发时自动更新window.top head里面添加的vue style
  if (window.win().isFrame && isDev) {
    function getStyle(html) {
      let reg = html.match(/(<title>Vite App<\/title>[\s\S]+)/g)
      if (reg) {
        return reg[0]
      }
      return `<style></style>`
    }

    function removeVueStyle() {
      let title = $('title:nth-child(2)', window.win().doc.head)
      while (title.next().length) {
        title.next().remove()
      }
      title.remove()
    }

    window.onbeforeunload = removeVueStyle

    let observe = new MutationObserver(() => {
      removeVueStyle()
      let headHtml = window.document.head.innerHTML
      let reg = getStyle(headHtml)
      $(window.win().doc.head).append($(`<head>${reg}</head>`))
    });
    observe.observe(window.document.head, {
      attributes: true, //目标节点的属性变化
      childList: true, //目标节点的子节点的新增和删除
      characterData: true, //如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化
      subtree: true, //目标节点所有后代节点的attributes、childList、characterData变化
    });
  }
</script>
<script type="module" src="/src/main.js"></script>
</body>
</html>
